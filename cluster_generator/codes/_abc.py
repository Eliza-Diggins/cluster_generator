from abc import ABC, abstractmethod
from dataclasses import dataclass, fields
from pathlib import Path
from typing import Any, Callable, ClassVar, Type

from cluster_generator.ics import ClusterICs
from cluster_generator.utils import Instance, Self, Value, mylog, yaml


class RuntimeParameters(ABC):
    """
    Class representing the runtime parameters of a specific simulation code.

    Notes
    -----
    Simulation codes generically have 2 components for a given run (post-compilation): the IC's and the runtime parameters
    (RTPs). Every :py:class:`SimulationCode` has a corresponding :py:attr:`SimulationCode.rtp` instance connecting it to
    the corresponding runtime parameter class for it's code.

    The :py:class:`RuntimeParameters` class reads a default set of values, names, descriptions, etc. from disk, integrates
    the getting and setting of RTPs for instances (setting values) and classes (setting default values on disk) and also
    facilitates the writing of RTP templates for each code. The RTP template provides a correctly formatted, best-guess version
    of the runtime parameters in a ready-to-run way. These are not necessarily complete, but they are compatible with the
    IC's generated by the :py:class:`SimulationCode`.
    """

    def __init__(self, path: str | Path):
        """
        Initialize the RTP class from a .yaml file.

        Parameters
        ----------
        path: str
            The path to the RTP file.
        """
        self.path: Path = Path(path)

        # private backend variables
        self._defaults = None  # Stores the defaults when read from file.

    def __get__(self, instance: Instance, owner: Type[Instance]) -> Value:
        """
        Retrieve the RTPs parameters. Different behavior occurs if class calls versus instance calls.
        """
        if instance is None:
            if self._defaults is not None:
                pass
            else:
                with open(self.path, "r") as f:
                    self._defaults = yaml.load(f)

            return self._defaults

        else:
            # There is an instance provided, we expect to be accessing the instance._rtp attribute.
            if hasattr(instance, "_rtp") and instance._rtp is not None:
                # the instance _rtp already exists and should just be returned.
                pass
            else:
                # We need to set instance._rtp
                _defaults_raw = self.__get__(None, owner)  # create the defaults.
                instance._rtp = {
                    k: v["default_value"] for k, v in _defaults_raw.items()
                }

            return instance._rtp

    @classmethod
    def get_setters(
        cls, _: Instance, owner: Type[Instance]
    ) -> dict[str | Callable[[Instance, Type[Instance]], Any]]:
        """
        Get a dictionary of the RTP setters defined for this Runtime Parameter class.
        """
        setters = {}

        # Load complex setters
        for k, v in cls.__dict__.items():
            # iterate through all of the class's definitions and seek out set_...
            if "set_" in k and isinstance(v, Callable):
                # k is a setter,
                set_var: str = str(k).replace("set_", "")  # The RTP this setter is for.
                setters[set_var] = v

        for user_field in [
            _field for _field in fields(owner) if _field.metadata.get("type") == "U"
        ]:
            if user_field.metadata.get("flag", None) is not None:
                # this field has a flag to set.
                set_var: str = str(user_field.metadata["flag"])

                if user_field.metadata.get("setter", None) is not None:
                    setters[set_var] = user_field.metadata["setter"]
                else:
                    setters[set_var] = lambda _inst, _, __, _n=user_field.name: getattr(
                        _inst, _n
                    )

        return setters

    def deduce_instance_values(
        self, instance: Instance, owner: Type[Instance], ics: ClusterICs
    ) -> bool:
        """
        Given an instance of :py:class:`SimulationCode`, generate the corresponding RTPs from its compile-time fields and
        user fields.

        Parameters
        ----------
        instance: SimulationCode
            The instance to fill.
        owner: SimulationCode
            The class owning the instance.
        ics: ClusterICs
            The initial conditions.

        Returns
        -------
        bool
            ``True`` if the process failed. ``False`` otherwise.
        """
        mylog.info(f"Deducing {instance} RTPs from RuntimeParameters.")

        # Determine the available setters
        _setters = self.__class__.get_setters(instance, owner)
        mylog.debug(f"Setting {len(_setters)} RTPs in {instance}.")

        _failed = False
        for k, v in _setters.items():
            try:
                instance.rtp[k] = v(instance, owner, ics)
                mylog.debug(f"{k} -> {instance.rtp[k]}.")
            except Exception as e:
                mylog.error(f"Error setting {k}: {e.__repr__()}")
                _failed = True

        return _failed

    @abstractmethod
    def write_rtp_template(
        self, instance: Instance, owner: Type[Instance], path: str | Path
    ) -> Path:
        """
        Generate a ready-to-run RTP template for a given :py:class:`SimulationCode` instance.

        Parameters
        ----------
        instance: SimulationCode
            The simulation code instance to generate the rtp template for.
        owner: type
            The owner type for the simulation Code.
        path: str
            The path to the RTP file/directory at which to generate the template.

        Raises
        ------
        ValueError
            If the RTPs found in ``instance`` are invalid or have any issue.

        Notes
        -----

        .. warning::

            The template generated for the simulation code may not be the optimal (or even functional) RTPs for your science case.
            Templates are written to correctly specify all IC related fields, but additional fields are generally filled by defaults
            or simply not present. The user should consult with the user-guide for their code to fill in / change any missing values.

        """
        pass


@dataclass
class SimulationCode(ABC):
    """
    Class representation of a specific hydrodynamics simulation code.

    Notes
    -----
    Simulation codes generically have 3 components of interest to ``cluster_generator``:

    1. **Compile-time parameters**: are represented as ``field``'s of the :py:class:`SimulationCode` instance and are specified by
       the user at instantiation. Some :py:class:`SimulationCode` classes have a :py:meth:`from_install_directory` method which
       will read the compile-time parameters from the code's installation directory and fill in those fields.

    2. **Runtime parameters**: Are represented by the :py:class:`SimulationCode`'s :py:attr:`SimulationCode.rtp` attribute, which
       links the :py:class:`SimulationCode` to a :py:class:`RuntimeParameters` class. Every simulation code has a set of RTPs present
       on disk (descriptions, defaults, requirements, etc.) The exact nature of these may differ between codes but are always accessible
       via the class-attribute :py:attr:`SimulationCode.rtp`. Similarly, each instance of :py:class:`SimulationCode` has a set of RTPs, also
       accessed through :py:attr:`SimulationCode.rtp` which only contain the key and the value for each parameter. By default, these are the
       same as the defaults on disk, but they can be set by the user. Calling the :py:meth:`SimulationCode.determine_runtime_params` will convert
       the :py:class:`SimulationCode` fields (compile-time settings and user settings) into the correct values for the RTPs and a template version
       of the runtime-ready RTPs can be generated from the :py:meth:`SimulationCode.generate_rtp_template` method.

    3. **IC file**: Can be generated using the :py:meth:`SimulationCode.generate_ics` method.

    Examples
    --------

    For a generic code (say Flash), the ICs can be generated in a compliant, ready-to-run format in the following way:

    .. code-block:: python

        # initialize Flash code
        # compile_time_settings and user_settings can be found in the relevant documentation.
        flash_sim = Flash(**compile_time_settings,**user_settings)

        # fill in the RTPs
        flash_sim.determine_runtime_params()

        # Create the RTP template
        flash_sim.generate_rtp_template("./flash_simulation/paramfile")

        # Create the ICs
        flash_sim.generate_ics(initial_conditions) #initial_conditions is a ClusterICs object.
    """

    rtp: ClassVar[
        RuntimeParameters
    ] = None  # -> specifies the RuntimeParameter instance associated with this software.
    """ RuntimeParameters: The runtime parameters for the simulation code.

    If accessed as a class attribute, will yield a dictionary of named tuples with a variety of fields including ``flag`` and
    ``default_value``. These are the default form of the RTPs stored on disk. If accessed as an instance attribute, then only 2
    fields are available: ``flag`` and ``value``.
    """
    # Compile time flags

    # User Specified Fields

    def __post_init__(self):
        # Initialize the instance._rtp attribute to store instance-level RTPs
        self._rtp = None

    def __str__(self):
        return f"<SimulationCode name={self.__class__.__name__}>"

    def __repr__(self):
        return self.__str__()

    @classmethod
    def get_rtp_class(cls) -> RuntimeParameters:
        """Fetch the :py:class:`RuntimeParameters` associated with the class."""
        return cls.__dict__["rtp"]

    def determine_runtime_params(self, ics: ClusterICs):
        """
        Use the specified compile-time settings and user settings to fill in missing RTPs.

        Notes
        -----

        On instantiation, :py:class:`SimulationCode` sets the instance's RTPs equal to the default values found in the
        class's default RTPs. The class's :py:class:`RuntimeParameters` class will then have a defined list of "setters", all of
        which are run on the instance to interpret the correct rtp values.
        """
        rtp_class: RuntimeParameters = self.get_rtp_class()
        rtp_class.deduce_instance_values(self, self.__class__, ics)

    def from_install_directory(
        self, installation_directory: str | Path, **parameters
    ) -> Self:
        """
        Instantiate the :py:class:`SimulationCode` class from the installation directory of the corresponding
        simulation software.

        Parameters
        ----------
        installation_directory: str
            The directory in which the software is installed.
        parameters
            Additional parameters to fill. If a compile-time parameter is set by parameters, it will take precedence
            over the corresponding value found on inspection. User's should also provide user fields in the parameters.

        Returns
        -------
        SimulationCode
            The corresponding :py:class:`SimulationCode` instance.

        Notes
        -----

        .. warning::

            This method may not be implemented in all simulation software classes.

        This method creates the instance by inspecting the configuration files of the simulation software to determine the
        relevant compile-time settings.
        """
        raise NotImplementedError(
            f"This method is not implemented for {self.__class__.__name__}."
        )

    @abstractmethod
    def generate_ics(self, initial_conditions: ClusterICs) -> Path:
        """
        Generate the initial conditions file for this code and it's configuratio
        Parameters
        ----------
        initial_conditions: ClusterICs
            The initial conditions object to convert to the correct IC filetype for use in the simulation
            software.
        output_path: str
            The path at which to generate the IC file.
        args:
            Additional arguments specific to the particular code.
        kwargs:
            Additional key-word arguments specific to the particular cod
        Returns
        -------
        Path
            The path to the initial conditions file.
        """
        pass

    @abstractmethod
    def generate_rtp_template(self, path: str | Path) -> Path:
        """
        Create the necessary files / execute necessary procedures to setup RTPs for the simulation.

        Parameters
        ----------
        path: str
            The path at which to generate the RTPs. In some simulation codes, this may be a directory, in others a single
            path.

        Notes
        -----
        This method is designed to take the RTPs specified in the code-class and write them in the necessary format for a run.
        This only extends to dumping a "as-complete-as-possible" set of RTPs; if users are executing the simulation software
        with additional flags or special physics, these may not be present in the RTPs generated by ``cluster_generator``. The
        intention of this method is to fill-in the RTPs that are directly relevant to the ``cluster_generator`` ICs.
        """
        return self.get_rtp_class().write_rtp_template(self, type(self), path)
