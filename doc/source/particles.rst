.. _particles:

Particles
---------

Generating Particles from ``ClusterModel`` Objects
==================================================

Once a :class:`~cluster_generator.cluster_model.ClusterModel` object is created,
it can be used to generate particle positions and velocities, of gas, dark matter,
and/or star types. The positions are generated by drawing uniform random numbers 
:math:`u \in [0, 1]`, and inverting the equation :math:`u = M(<r)/M_{\rm tot}` 
to find the radius :math:`r`. Since the cluster is spherically symmetric, the 
particle positions are isotropically distributed in the tangential directions 
:math:`\theta` and :math:`\phi`. Masses are also assigned to the particles based
on the number of particles and the total mass of the gas, dark matter, or stars.

These fields are named ``"particle_position"``, ``"particle_velocity"``, and
``"particle_mass"``. The first two have shapes of ``(number_of_particles, 3)``
(containing all three components of each), and the latter has a shape of 
``number_of_particles``.

Gas Particles
+++++++++++++

Gas particles are initialized in hydrostatic equilibrium from the profiles. In
addition to the fields mentioned above, gas particles also have ``"density"``,
and ``"thermal_energy"`` fields. They may optionally also have a
``"magnetic_field"`` field, which is a vector field with shape 
``(number_of_particles, 3)``. This field is not derived from hydrostatic
equilibrium and thus needs to be set later by the user, either by hand or
from a 3D field. See :ref:`map_fields_to_particles` for details. 

To generate gas particles, use the 
If you want to add a field with the particle gravitational
potential, set ``compute_potential=True``. If you want to limit the
generation of particles to within a certain radius, set ``r_max`` equal to
the desired radius in kpc (otherwise the maximum radius will be the value 
which was originally supplied in the creation of the
:class:`~cluster_generator.cluster_model.ClusterModel` object):

.. code-block:: python

    n_gas = 1000000 # number of particles to generate (now within r_max)
    r_max = 5000.0 # maximum radius of particles in kpc
    gas_particles = p.generate_gas_particles(n_gas, r_max=r_max, 
                                             compute_potential=True)

Dark Matter and Star Particles
++++++++++++++++++++++++++++++

Dark matter and star particles are initialized with velocities assuming
collisionless dynamics and virial equilibrium with the underlying 
gravitational potential from all mass sources. 

Mathematical Overview
^^^^^^^^^^^^^^^^^^^^^

The mass density :math:`\rho({\bf r})` of such a system can be derived by 
integrating the phase-space distribution function :math:`f({\bf r}, {\bf v})` 
over velocity space: 

.. math::

    \rho({\bf r}) = \int{f({\bf r}, {\bf v})d^3{\bf v}}

where :math:`{\bf r}` and :math:`{\bf v}` are the position and velocity
vectors. Assuming spherical symmetry and isotropy, all quantities are simply
functions of the scalars :math:`r` and :math:`v`, and 
:math:`d^3{\bf v} = 4\pi{v^2}dv`:

.. math::

    \rho(r) = 4\pi\int{f(r, v)v^2dv}

Assuming zero net angular momentum for the cluster, there is a unique 
distribution function :math:`f(E)` which corresponds to the density 
:math:`\rho(r)`. Since the total energy of a particle is 
:math:`E = v^2/2 + \Phi` (where :math:`\Phi(r)` is the gravitational
potential) and further defining :math:`\Psi = -\Phi` and 
:math:`{\cal E} = -E = \Psi - \frac{1}{2}v^2`, we find:

.. math::

    \rho(r) = 4\pi\int_0^{\Psi}f({\cal E})\sqrt{2(\Psi-{\cal E})}d{\cal E}

After differentiating this equation once with respect to :math:`\Psi` and
inverting the resulting Abel integrel equation, we finally have:

.. math::

    f({\cal E}) = \frac{1}{\sqrt{8}\pi^2}\left[\int^{\cal E}_0{d^2\rho \over d\Psi^2}{d\Psi
    \over \sqrt{{\cal E} - \Psi}} + \frac{1}{\sqrt{{\cal E}}}\left({d\rho \over d\Psi}\right)_{\Psi=0} \right]

which given a density-potential pair for an equilibrium halo, can be used to
determine particle speeds. For our cluster models, this equation must (in 
general) be solved numerically, even if the underlying dark matter, stellar, 
and gas densities can be expressed analytically. 

To generate the particle speeds, the distribution function :math:`f({\cal E})`
is used with uniform random numbers :math:`u \in [0, 1]` via an 
acceptance-rejection method. The particle velocity components are isotropically
distributed in the tangential directions :math:`\theta` and :math:`\phi`.

Checking the Virial Equilibrium
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It is probably a good idea to check that the resulting distribution functions
for the dark matter and/or stars are consistent with the input mass density 
profiles. The :meth:`~cluster_generator.cluster_model.ClusterModel.check_dm_virial` 
or :meth:`~cluster_generator.cluster_model.ClusterModel.check_star_virial` 
methods can be used to perform a quick check on the accuracy of the virial 
equilibrium model for each of these types. These methods return two NumPy 
arrays, the first being the density profile computed from integrating the 
distribution function, and the second being the relative difference between 
the input density profile and the one calculated using this method.

.. code-block:: python

    import matplotlib.pyplot as plt
    rho, diff = p.check_dm_virial()
    # Plot this up
    fig, ax = plt.subplots(figsize=(10,10))
    ax.loglog(vir["radius"], vir["dark_matter_density"], 'x', 
              label="Input mass density", markersize=10)
    ax.loglog(vir["radius"], rho, label="Derived mass density", lw=3)
    ax.legend()
    ax.set_xlabel("r (kpc)")
    ax.set_ylabel("$\mathrm{\\rho\ (M_\odot\ kpc^{-3})}$")

.. image:: _images/check_density.png

One can see that the derived density diverges from the input density at large
radii, due to difficulties with numerically integrating to infinite radius. So long
as the maximum radius of the profile is very large, this should not matter very
much.

Generating Dark Matter and Star Particles
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The :meth:`~cluster_generator.cluster_model.ClusterModel.generate_dm_particles`
and :meth:`~cluster_generator.cluster_model.ClusterModel.generate_star_particles`
methods carry out these functions for dark matter and stars respectively, and 
also assigns particle masses, given the number of particles one wishes to be 
generated:

.. code-block:: python
    
    n_dm = 1000000 # number of DM particles to generate
    n_star = 10000 # number of star particles to generate
    dm_particles = p.generate_dm_particles(n_dm)
    star_particles = p.generate_star_particles(n_star)

If you want to add a field with the particle gravitational
potential, set ``compute_potential=True``. If you want to limit the
generation of particles to within a certain radius, set ``r_max`` equal to
the desired radius in kpc (otherwise the maximum radius will be the value 
which was originally supplied in the creation of the
:class:`~cluster_generator.cluster_model.ClusterModel` object):

.. code-block:: python

    n_dm = 1000000 # number of particles to generate (now within r_max)
    r_max = 5000.0 # maximum radius of particles in kpc
    dm_particles = p.generate_dm_particles(n_dm, r_max=r_max, 
                                           compute_potential=True)

The object returned in any of these cases is  
a :class:`~cluster_generator.particles.ClusterParticles` object,
which is covered in more detail next.

The ``ClusterParticles`` Class
==============================

