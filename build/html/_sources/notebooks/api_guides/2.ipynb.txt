{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "4ecd93fd26ba5cb",
   "metadata": {
    "collapsed": false
   },
   "source": [
    "# Virialization\n",
    "\n",
    "One of the key parts of initializing N-body simulations is to determine not only the particle positions, but also their velocities. Doing so can be a tricky business as constructing systems which have dynamical stability is a mathematically non-trivial task. What's more, in modified gravities / non-newtonian gravities it may be impossible to use many of the standard tools available in the standard dynamical literature. \n",
    "\n",
    "In the ``cluster_generator`` library, there are currently 2 implemented approaches for undertaking this task: the first uses the Eddington formula, and the second the Local Maxwellian Approximation. This guide will take you step by step through the necessary background to understand not only how these approaches work, but also which is best for your current project.\n",
    "\n",
    "---\n",
    "\n",
    "## Conents\n",
    "\n",
    "- [Galactic Dynamics](#Galactic-Dynamics)\n",
    "  - [The Distribution Function](#The-Distribution-Function)\n",
    "  - [The Collisionless Boltzmann Equation](#The-Collisionless-Boltzmann-Equation)\n",
    "  - [The Jean's Equation](#The-Jeans-Equation)\n",
    "  - [The Jean's Theorem](#The-Jeans-Theorem)\n",
    "- [The Eddington Formula](#The-Eddington-Formula)\n",
    "- [The Local Maxwellian Approximation](#The-Local-Maxwellian-Approximation)\n",
    "- [Virialization in ``cluster_generator``](#Virialization-in-cluster_generator)\n",
    "\n",
    "---\n",
    "\n",
    "## Galactic Dynamics\n",
    "\n",
    "Before we begin discussing the nuts and bolts of each method, it is worth reviewing some of the basic tenants of galactic dynamics. For a useful reference and for deeper information, see [Binney and Tremaine](#binney-tremaine).\n",
    "\n",
    "### The Distribution Function\n",
    "\n",
    "In describing the necessary mathematics of this task, we are interested in determining the correct positions and velocities to assign to an ensemble of particles in the chosen simulation domain. Generically, it is useful to refer to the system using its **distribution function** $f(\\textbf{x},\\textbf{v}) $, which acts as the probability distribution function in the phase space of the system\n",
    "spanned by all possible values of the position and velocity. In principle, if one knows $f(\\textbf{x},\\textbf{v})$, then the task of generating initial conditions is simple; just sample from the distribution function as needed. Unfortunately, this is often not a viable strategy and a considerable degree of manipulation is required to undertake this task. Nonetheless, the Eddington formula is a simplified case of determining the distribution function which is only viable in spherically symmetric potentials. In more complex cases, approximations or statistical methods are required. The Local Maxwellian approximation is one of these approaches, and aims to determine only moments of the distribution function instead of the distribution function itself.\n",
    "\n",
    "### The Collisionless Boltzmann Equation\n",
    "\n",
    "One of the most important results in classical mechanics is the so-called **Liouville Theorem**, which states that given an ensemble of states in a phase space, the local density of states in the neighborhood of any chosen states is constant. In a more intuitive sense, as an \"ensemble of systems\" flows through phase space with time, it forms an **incompressible flow**. In the context of classical dynamics, we often express this theorem as\n",
    "\n",
    "$$ \\frac{dD}{dt} = [D,\\mathcal{H}] + \\frac{\\partial D}{\\partial t} = \\frac{\\partial D}{\\partial t} + \\sum_{j=1}^{2N_{\\mathrm{dim}}} \\frac{\\partial D}{\\partial x_j} \\dot{x}_j,$$\n",
    "\n",
    "where $\\mathcal{H}$ is the systems Hamiltonian, and the brackets indicate the Poisson bracket notation. In the second expression, not that the summation is over coordinates in phase space, i.e. both velocity and space. \n",
    "\n",
    "Now, if one thinks of each particle as representing its own \"system\" subject to the Hamiltonian determined by the global gravitational properties of the system, but ignoring any potential for particle-particle interaction, then instead of the \"density of states\", we can instead simply use the distribution function. Furthermore, $\\dot{\\textbf{v}} = -\\nabla \\Phi$, which yields the equivalent statement\n",
    "\n",
    "$$ \\frac{\\partial f}{\\partial t} + \\textbf{v}\\cdot \\frac{\\partial f}{\\partial \\textbf{x}} - \\nabla \\Phi \\cdot \\frac{\\partial f}{\\partial \\textbf{v}} = 0. $$\n",
    "\n",
    "This equation is called the **Collisionless Boltzmann Equation**, or the **Vlasov Equation** and is of extreme importance to our current purpose.\n",
    "\n",
    "The key benefit that comes from this equation is that it can be used to determine moments of the distribution function. It should also be noted that the CBE is applicable <u>regardless of gravitational theory</u> as long as that they're described in Hamiltonian systems (those for which a Lagrangian / Lagrangian density can be consistently obtained in some form). Most importantly, because MOND (in its manifestations as AQUAL and QUMOND) is a classical field theory, it is also satisfied by the CBE.\n",
    "\n",
    "### The Jean's Equation\n",
    "\n",
    "By taking moments of the CBE, one can obtain Jean's equation, which has the form\n",
    "\n",
    "$$ \\nu \\left\\{\\frac{\\partial \\left<v_j\\right>}{\\partial t} + \\sum_i \\left<v_i\\right> \\frac{\\partial \\left<v_j\\right>}{\\partial x_i} + \\frac{\\partial \\Phi}{\\partial x_j}\\right\\} + \\sum_i \\frac{\\partial \\left(\\nu \\sigma_{ij}^2\\right)}{\\partial x_i} = 0, $$\n",
    "\n",
    "where $\\nu$ is the **position space density**, and $\\Phi$ is the **force-conveying potential**. We make a special point of noting that it us the <u>force-conveying</u> potential because in multi-potential theories (QUMOND for example), the potential in the Jean's equation must refer to the potential from which the force is derived. The Jean's equation becomes very important in the Local Maxwellian Approach.\n",
    "\n",
    "### The Jean's Theorem\n",
    "\n",
    "Not to be confused with the [Jean's Equation](#The-Jean's-Equation), the Jean's Theorem states the following\n",
    "\n",
    "<div class=\"alert alert-block alert-info\">\n",
    "<b>Theorem:</b> states that any steady-state solution of the collisionless Boltzmann equation depends on the phase space coordinates only through integrals of motion in the given potential, and conversely any function of the integrals is a steady-state solution.\n",
    "</div>\n",
    "\n",
    "Generally, this fact isn't that useful. After all, actually finding the integrals of motion is a troublesome task in and of itself. Fortunately, in spherical symmetry, 4 integrals of motion can be relatively easily provided: $E, \\textbf{L}$. In fact, we may even state a special case of the theorem which applies in spherically symmetric systems:\n",
    "\n",
    "\n",
    "<div class=\"alert alert-block alert-info\">\n",
    "<b>Theorem:</b> The distribution function $f(\\textbf{x},\\textbf{v})$ depends <u>only</u> on the angular momentum and the energy in a spherically symmetric system. When the system is irrotational, the distribution function then reduces to a function of only the energy.\n",
    "</div>\n",
    "\n",
    "## The Eddington Formula\n",
    "\n",
    "Now its time to get down to the business of actually using any of this information. Recalling that $f$ is the distribution function, we may combine this with the poisson equation to obtain\n",
    "\n",
    "$$ \\int f(\\textbf{x},\\textbf{v}) d^3\\textbf{v} = \\frac{1}{4\\pi G} \\nabla^2 \\Phi$$\n",
    "\n",
    "Consider a velocity distribution function $ f(\\textbf{v}) $. Then (in Newtonian gravity), the RHS of the equation may be expanded in spherical coordinates to yield a non-trivial differential equation in $ f $.In the case of galaxy clusters, the Jean's Theorem applies, stipulating that $ f $ be a function only of energy and angular momentum. If,as is typical, we assume that the system is irrotational, the angular momentum is constant and the function becomes dependent onlyon the energy. To simplify the notation, we denote the **relative potential** to be $ \\Psi = -\\Phi + \\Phi_0 $ and the relative energyto be $ \\mathcal{E} = -E + \\Phi_0 = \\Psi - \\frac{1}{2}v^2 $.  In this case, the equation above may be simplified to the form\n",
    "\n",
    "$$ \\rho(r) = 4\\pi \\int_0^\\Psi f(\\mathcal{E})\\sqrt{2(\\Psi - \\mathcal{E})} d\\mathcal{E}.$$\n",
    "\n",
    "If $ \\rho $ is considered a function of the relative potential, then one may obtain the equation\n",
    "\n",
    "$$    \\frac{1}{\\sqrt{8}\\pi}\\frac{d\\rho}{d\\Psi} = \\int_0^\\Psi \\frac{f(\\mathcal{E}) d\\mathcal{E}}{\\sqrt{\\Psi-\\mathcal{E}}} $$\n",
    "\n",
    "Blinney and Tremaine note that this is an Abel integral and may be inverted to yield \n",
    "\n",
    "$$    f(\\mathcal{E}) = \\frac{1}{\\sqrt{8}\\pi^2} \\frac{d}{d\\mathcal{E}}\\int_0^\\mathcal{E} \\frac{d\\rho}{d\\Psi} \\frac{d\\Psi}{\\sqrt{\\mathcal{E}-\\Psi}} $$\n",
    "\n",
    "This is the approach used in ``cluster_generator`` for the generation of virialized systems when using Newtonian dynamics.\n",
    "\n",
    "<div class=\"alert alert-block alert-info\">\n",
    "<b>Note:</b> While this approach is viable in Newtonian gravity, its reliance on the classical poisson equation makes it non-implementable for MOND gravities.\n",
    "</div>\n",
    "\n",
    "## The Local Maxwellian Approximation\n",
    "While the Eddington Formula provides an ideal approach in Newtonian gravity, when using non-newtonian gravity or badly behaved profiles even in Newtonian\n",
    "gravity, analytical approaches may become non-viable; however, the Local Maxwellian approximation (LMA) can be used to obtain a viable estimate\n",
    "for the distribution function nonetheless. Consider the Jeans Equation in spherically symmetry:\n",
    "\n",
    "$$\\frac{\\partial \\rho \\sigma_r^2}{\\partial r} + \\frac{2\\rho}{r}\\left(\\sigma_r^2 -\\sigma^2_\\theta\\right) + \\rho \\frac{\\partial \\Phi}{\\partial r} = 0.$$\n",
    "\n",
    "If one also assumes that the stress tensor is entirely isotropic, then the equation may be manipulated to allow one to find the velocity dispersion\n",
    "\n",
    "$$ \\sigma_r^2 = \\frac{1}{\\rho_h}\\int_r^\\infty \\rho_h \\frac{d\\Phi}{dr} dr $$\n",
    "\n",
    "We are then able to assume a gaussian distribution function for the velocities, and thus a maxwellian distribution for the speeds\n",
    "\n",
    "$$ F(v,r) = 4\\pi \\left(\\frac{1}{2\\pi \\sigma_r^2}\\right) v^2 \\exp\\left(\\frac{-v^2}{2\\sigma_r^2}\\right) $$\n",
    "\n",
    "\n",
    "## Virialization in ``cluster_generator``\n",
    "\n",
    "---\n",
    "\n",
    "Let's look at an example of how this plays out in the ``cluster_generator`` library. First off, we're going to load a ``ClusterModel`` instance from file:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "cluster_generator : [INFO     ] 2023-09-02 16:30:27,458 Loading ClusterModel instance from profile_1.h5.\n"
     ]
    }
   ],
   "source": [
    "# -- imports -- #\n",
    "import cluster_generator as cg\n",
    "\n",
    "# -- loading the model -- #\n",
    "\n",
    "model = cg.ClusterModel.from_h5_file(\"profile_1.h5\")"
   ],
   "metadata": {
    "collapsed": false,
    "ExecuteTime": {
     "end_time": "2023-09-02T22:30:27.787925900Z",
     "start_time": "2023-09-02T22:30:22.910046600Z"
    }
   },
   "id": "a9d2e1f0dbf4b7f0"
  },
  {
   "cell_type": "markdown",
   "source": [
    "So we've loaded in a ``ClusterModel`` object, to what whats going on with the virialization, we are interested in the ``.<ptype>_virial`` attributes:"
   ],
   "metadata": {
    "collapsed": false
   },
   "id": "b11cd75a00766e2d"
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The dm_virial attribute is <cluster_generator.virial.VirialEquilibrium object at 0x7f5675f5d220> which has type lma.\n"
     ]
    }
   ],
   "source": [
    "print(f\"The dm_virial attribute is {model.dm_virial} which has type {model.dm_virial.type}.\")"
   ],
   "metadata": {
    "collapsed": false,
    "ExecuteTime": {
     "end_time": "2023-09-02T22:30:27.794955600Z",
     "start_time": "2023-09-02T22:30:27.792923200Z"
    }
   },
   "id": "3b55847bd94836d2"
  },
  {
   "cell_type": "markdown",
   "source": [
    "So we see that there is already a ``VirialEquilibrium`` object with type ``lma``, which indicates that Local Maxwellian Approximation was done. \n",
    "\n",
    "We aren't that interested in looking at something that's already virialized. Let's reset it:"
   ],
   "metadata": {
    "collapsed": false
   },
   "id": "1f60deb0b0b37814"
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The dm_virial attribute is None\n"
     ]
    }
   ],
   "source": [
    "model._dm_virial = None # Notice the _, this is actually a private attribute\n",
    "\n",
    "print(f\"The dm_virial attribute is {model._dm_virial}\")"
   ],
   "metadata": {
    "collapsed": false,
    "ExecuteTime": {
     "start_time": "2023-09-02T22:30:28.023736700Z"
    }
   },
   "id": "2f9b7bb006c2b24b"
  },
  {
   "cell_type": "markdown",
   "source": [
    "Okay, so why the ``_`` before? Technically ``model.dm_virial`` is a ``@property`` that checks if there is a virialization method and automatically generates it if not:"
   ],
   "metadata": {
    "collapsed": false
   },
   "id": "d4e4afbaabcc8e92"
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "outputs": [
    {
     "data": {
      "text/plain": "Computing particle dispersions (LMA) :   0%|          | 0/10000 [00:00<?, ?it/s]",
      "application/vnd.jupyter.widget-view+json": {
       "version_major": 2,
       "version_minor": 0,
       "model_id": "5e4954d68f2b41ce85c708cfc46ac1d7"
      }
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The dm_virial attribute is <cluster_generator.virial.VirialEquilibrium object at 0x7f5675f5d7f0> which has type lma.\n"
     ]
    }
   ],
   "source": [
    "_ = model.dm_virial\n",
    "\n",
    "print(f\"The dm_virial attribute is {model.dm_virial} which has type {model.dm_virial.type}.\")"
   ],
   "metadata": {
    "collapsed": false,
    "ExecuteTime": {
     "start_time": "2023-09-02T22:30:28.082040200Z"
    }
   },
   "id": "589d924d991808c1"
  },
  {
   "cell_type": "markdown",
   "source": [
    "Okay, so we've successfully computed the LMA particle dispersions (yipee!), what does that actually mean? Under the hood, ``cluster_generator`` is accessing a script which computes the integral\n",
    "\n",
    "$$ \\sigma_r^2 = \\frac{1}{\\rho_h}\\int_r^\\infty \\rho_h \\frac{d\\Phi}{dr} dr $$\n",
    "\n",
    "and determines $\\sigma_r^2$. Now, when the software is ready to generate the actual particles, we've already got the dispersion that has to be provided to the Maxwellian distribution and all that has to happen is for us to sample the data. How do you do that?"
   ],
   "metadata": {
    "collapsed": false
   },
   "id": "42a414c89c864d96"
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "cluster_generator : [INFO     ] 2023-09-02 16:32:01,615 We will be assigning 1000 dark_matter particles.\n",
      "cluster_generator : [INFO     ] 2023-09-02 16:32:01,617 Compute 1000 particle positions.\n",
      "cluster_generator : [INFO     ] 2023-09-02 16:32:01,628 Computing dark_matter velocities using lma method.\n"
     ]
    },
    {
     "data": {
      "text/plain": "Generating particle velocities [LMA]:   0%|          | 0/1000 [00:00<?, ?it/s]",
      "application/vnd.jupyter.widget-view+json": {
       "version_major": 2,
       "version_minor": 0,
       "model_id": "d66fb150af7048aaacd8218d28a20823"
      }
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "parts = model.dm_virial.generate_particles(1000)"
   ],
   "metadata": {
    "collapsed": false,
    "ExecuteTime": {
     "start_time": "2023-09-02T22:32:01.616664700Z"
    }
   },
   "id": "ea71c9155e7a722d"
  },
  {
   "cell_type": "markdown",
   "source": [
    "At this stage, we're referencing the underlying cython code where the PDF can be inverse cummulatively sampled many millions of times. This process is quite quick due to the static typing of cython. Let's take a look at what things actually look like:"
   ],
   "metadata": {
    "collapsed": false
   },
   "id": "5e6f46947ec19a2"
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "cluster_generator : [INFO     ] 2023-09-02 16:32:01,661 We will be assigning 100000 dark_matter particles.\n",
      "cluster_generator : [INFO     ] 2023-09-02 16:32:01,664 Compute 100000 particle positions.\n",
      "cluster_generator : [INFO     ] 2023-09-02 16:32:01,706 Computing dark_matter velocities using lma method.\n"
     ]
    },
    {
     "data": {
      "text/plain": "Generating particle velocities [LMA]:   0%|          | 0/100000 [00:00<?, ?it/s]",
      "application/vnd.jupyter.widget-view+json": {
       "version_major": 2,
       "version_minor": 0,
       "model_id": "9b796c2f064e45b6b0b992c3cf6e5734"
      }
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "yt : [INFO     ] 2023-09-02 16:32:03,056 Parameters: current_time              = 0.0\n",
      "yt : [INFO     ] 2023-09-02 16:32:03,057 Parameters: domain_dimensions         = [1 1 1]\n",
      "yt : [INFO     ] 2023-09-02 16:32:03,059 Parameters: domain_left_edge          = [0. 0. 0.]\n",
      "yt : [INFO     ] 2023-09-02 16:32:03,061 Parameters: domain_right_edge         = [10000. 10000. 10000.]\n",
      "yt : [INFO     ] 2023-09-02 16:32:03,062 Parameters: cosmological_simulation   = 0\n"
     ]
    }
   ],
   "source": [
    "# -- regenerate parts with more particles -- #\n",
    "parts = model.dm_virial.generate_particles(100_000)\n",
    "parts.add_offsets([5000,5000,5000],[0,0,0])\n",
    "\n",
    "df = parts.to_yt_dataset(10000)"
   ],
   "metadata": {
    "collapsed": false,
    "ExecuteTime": {
     "start_time": "2023-09-02T22:32:01.665869100Z"
    }
   },
   "id": "8f82bd8453d0a0ad"
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "yt : [INFO     ] 2023-09-02 16:32:03,069 Allocating for 1e+05 particles\n"
     ]
    },
    {
     "ename": "TypeError",
     "evalue": "__init__() got an unexpected keyword argument 'weight'",
     "output_type": "error",
     "traceback": [
      "\u001B[0;31m---------------------------------------------------------------------------\u001B[0m",
      "\u001B[0;31mTypeError\u001B[0m                                 Traceback (most recent call last)",
      "Cell \u001B[0;32mIn[7], line 3\u001B[0m\n\u001B[1;32m      1\u001B[0m \u001B[38;5;28;01mimport\u001B[39;00m \u001B[38;5;21;01myt\u001B[39;00m\n\u001B[0;32m----> 3\u001B[0m p \u001B[38;5;241m=\u001B[39m \u001B[43myt\u001B[49m\u001B[38;5;241;43m.\u001B[39;49m\u001B[43mParticlePlot\u001B[49m\u001B[43m(\u001B[49m\u001B[43mdf\u001B[49m\u001B[43m,\u001B[49m\u001B[43m(\u001B[49m\u001B[38;5;124;43m\"\u001B[39;49m\u001B[38;5;124;43mall\u001B[39;49m\u001B[38;5;124;43m\"\u001B[39;49m\u001B[43m,\u001B[49m\u001B[38;5;124;43m\"\u001B[39;49m\u001B[38;5;124;43mparticle_position_x\u001B[39;49m\u001B[38;5;124;43m\"\u001B[39;49m\u001B[43m)\u001B[49m\u001B[43m,\u001B[49m\u001B[43m(\u001B[49m\u001B[38;5;124;43m\"\u001B[39;49m\u001B[38;5;124;43mall\u001B[39;49m\u001B[38;5;124;43m\"\u001B[39;49m\u001B[43m,\u001B[49m\u001B[38;5;124;43m\"\u001B[39;49m\u001B[38;5;124;43mparticle_position_y\u001B[39;49m\u001B[38;5;124;43m\"\u001B[39;49m\u001B[43m)\u001B[49m\u001B[43m,\u001B[49m\u001B[43m(\u001B[49m\u001B[38;5;124;43m\"\u001B[39;49m\u001B[38;5;124;43mall\u001B[39;49m\u001B[38;5;124;43m\"\u001B[39;49m\u001B[43m,\u001B[49m\u001B[38;5;124;43m\"\u001B[39;49m\u001B[38;5;124;43mparticle_mass\u001B[39;49m\u001B[38;5;124;43m\"\u001B[39;49m\u001B[43m)\u001B[49m\u001B[43m,\u001B[49m\u001B[43mweight\u001B[49m\u001B[38;5;241;43m=\u001B[39;49m\u001B[38;5;28;43;01mNone\u001B[39;49;00m\u001B[43m)\u001B[49m\n\u001B[1;32m      4\u001B[0m p\u001B[38;5;241m.\u001B[39mshow()\n",
      "File \u001B[0;32m~/.virtualenvs/cluster_generator/lib/python3.8/site-packages/yt/visualization/particle_plots.py:782\u001B[0m, in \u001B[0;36mParticlePlot\u001B[0;34m(ds, x_field, y_field, z_fields, color, *args, **kwargs)\u001B[0m\n\u001B[1;32m    778\u001B[0m         \u001B[38;5;28;01mbreak\u001B[39;00m\n\u001B[1;32m    780\u001B[0m \u001B[38;5;28;01mif\u001B[39;00m direction \u001B[38;5;241m<\u001B[39m \u001B[38;5;241m3\u001B[39m:\n\u001B[1;32m    781\u001B[0m     \u001B[38;5;66;03m# Make a ParticleProjectionPlot\u001B[39;00m\n\u001B[0;32m--> 782\u001B[0m     \u001B[38;5;28;01mreturn\u001B[39;00m \u001B[43mParticleProjectionPlot\u001B[49m\u001B[43m(\u001B[49m\u001B[43mds\u001B[49m\u001B[43m,\u001B[49m\u001B[43m \u001B[49m\u001B[43mdirection\u001B[49m\u001B[43m,\u001B[49m\u001B[43m \u001B[49m\u001B[43mz_fields\u001B[49m\u001B[43m,\u001B[49m\u001B[43m \u001B[49m\u001B[43mcolor\u001B[49m\u001B[43m,\u001B[49m\u001B[43m \u001B[49m\u001B[38;5;241;43m*\u001B[39;49m\u001B[43margs\u001B[49m\u001B[43m,\u001B[49m\u001B[43m \u001B[49m\u001B[38;5;241;43m*\u001B[39;49m\u001B[38;5;241;43m*\u001B[39;49m\u001B[43mkwargs\u001B[49m\u001B[43m)\u001B[49m\n\u001B[1;32m    784\u001B[0m \u001B[38;5;66;03m# Does not correspond to any valid PlotWindow-style plot,\u001B[39;00m\n\u001B[1;32m    785\u001B[0m \u001B[38;5;66;03m# use ParticlePhasePlot instead\u001B[39;00m\n\u001B[1;32m    786\u001B[0m \u001B[38;5;28;01melse\u001B[39;00m:\n\u001B[1;32m    787\u001B[0m     \u001B[38;5;28;01mreturn\u001B[39;00m ParticlePhasePlot(dd, x_field, y_field, z_fields, color, \u001B[38;5;241m*\u001B[39margs, \u001B[38;5;241m*\u001B[39m\u001B[38;5;241m*\u001B[39mkwargs)\n",
      "\u001B[0;31mTypeError\u001B[0m: __init__() got an unexpected keyword argument 'weight'"
     ]
    }
   ],
   "source": [
    "import yt\n",
    "\n",
    "p = yt.ParticlePlot(df,(\"all\",\"particle_position_x\"),(\"all\",\"particle_position_y\"),(\"all\",\"particle_mass\"),weight=None)\n",
    "p.show()"
   ],
   "metadata": {
    "collapsed": false,
    "ExecuteTime": {
     "start_time": "2023-09-02T22:32:03.073287100Z"
    }
   },
   "id": "457590cb69139311"
  },
  {
   "cell_type": "markdown",
   "source": [
    "\n",
    "\n",
    "---\n",
    "\n",
    "## References\n",
    "\n",
    "<a name=\"binney-tremaine\"> Binney, J., & Tremaine, S. (2011). Galactic dynamics (Vol. 20). Princeton university press. </a>\n",
    "\n",
    "---\n"
   ],
   "metadata": {
    "collapsed": false
   },
   "id": "c3b71ce2b1c3ad1e"
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "outputs": [],
   "source": [
    "\n"
   ],
   "metadata": {
    "collapsed": false,
    "ExecuteTime": {
     "start_time": "2023-09-02T22:32:03.698068400Z"
    }
   },
   "id": "d2f70b6cf40180ab"
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
